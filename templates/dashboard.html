<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>{{ t(request, 'dashboard.title') }}</title>
		<style>
			body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
			h1 { margin-bottom: 12px; }
			.grid { display: grid; grid-template-columns: 1fr; gap: 24px; }
			@media (min-width: 1000px) { .grid { grid-template-columns: 1fr 1fr; } }
			.card { border: 1px solid #e5e7eb; border-radius: 8px; overflow: hidden; }
			.card h2 { margin: 0; padding: 12px 16px; background: #f9fafb; border-bottom: 1px solid #e5e7eb; font-size: 16px; }
            table { width: 100%; border-collapse: collapse; }
			th, td { padding: 8px 12px; border-bottom: 1px solid #f0f0f0; text-align: left; font-size: 14px; }
			th { background: #fafafa; position: sticky; top: 0; }
			.caption { color: #6b7280; font-size: 12px; padding: 8px 16px; }
			.toolbar { margin-bottom: 12px; }
			.toolbar .nav { display:flex; gap:8px; flex-wrap:wrap; padding:8px; background:#f8fafc; border:1px solid #e5e7eb; border-radius:8px; }
			.toolbar .nav a { padding:6px 10px; border-radius:6px; color:#1f2937; text-decoration:none; border:1px solid transparent; }
			.toolbar .nav a:hover { background:#eef2ff; border-color:#c7d2fe; color:#1d4ed8; }
            tr.paid { background: #eaffea; }
            tr.unpaid { background: #fff9db; }
		</style>
	</head>
	<body>
		{% include "_nav.html" %}
		<h1>{{ t(request, 'dashboard.heading') }}</h1>
		<div class="caption">
			{% if days and since_date %}
				Son {{ days }} gün ({{ since_date }}) verisi gösteriliyor.
			{% endif %}
		</div>
		<div style="display:flex;gap:12px;flex-wrap:wrap;margin:10px 0 18px 0;">
			<div class="card" style="padding:8px 12px;">
				<strong>{{ t(request, 'dashboard.total_sales') }}:</strong> {{ '%.2f'|format(total_sales or 0) }}
			</div>
			<div class="card" style="padding:8px 12px;">
				<strong>{{ t(request, 'dashboard.net_collected') }}:</strong> {{ '%.2f'|format(total_collected or 0) }}
			</div>
			<div class="card" style="padding:8px 12px;">
				<strong>{{ t(request, 'dashboard.to_collect') }}:</strong> {{ '%.2f'|format(total_to_collect or 0) }}
			</div>
			<div class="card" style="padding:8px 12px;">
				<strong>{{ t(request, 'dashboard.total_fees') }}:</strong> {{ '%.2f'|format(total_fees or 0) }}
			</div>
		</div>
		<div class="toolbar">
			<form id="uploadForm" method="post" action="/import/upload" enctype="multipart/form-data" style="display:inline-block;margin-left:12px;">
				<select name="source" style="padding:6px 8px;border:1px solid #ddd;border-radius:6px;">
					<option value="bizim">{{ t(request, 'sources.bizim') }}</option>
					<option value="kargo">{{ t(request, 'sources.kargo') }}</option>
					<option value="returns">{{ t(request, 'sources.returns') }}</option>
				</select>
				<input type="file" name="files" multiple accept=".xlsx" required style="margin-left:6px" />
				<button type="submit" style="margin-left:6px;background:#2563eb;color:#fff;border:none;border-radius:6px;padding:6px 10px;cursor:pointer">{{ t(request, 'dashboard.upload') }}</button>
				<label style="margin-left:10px; font-size:12px; color:#475569;">
					<input type="checkbox" name="skip_duplicates" id="skipDupDash" checked />
					Duplicate satırları skip et
				</label>
			</form>
		</div>

		<div id="uploadResult" class="caption"></div>
		<div class="grid">
			<div class="card">
				<h2>Günlük Sipariş Akışı</h2>
				<div style="padding:12px;">
					<canvas id="dailyCountsChart" width="520" height="320" style="width:100%; max-width:100%;"></canvas>
					<div id="dailyCountsLegend" class="caption" style="padding:8px 0;"></div>
				</div>
			</div>

			<div class="card">
				<h2>Günlük Ciro / Kâr / Maliyet</h2>
				<div style="padding:12px;">
					<canvas id="dailyFinancialsChart" width="520" height="320" style="width:100%; max-width:100%;"></canvas>
					<div id="dailyFinancialsLegend" class="caption" style="padding:8px 0;"></div>
				</div>
			</div>

			<div class="card">
<h2>{{ t(request, 'dashboard.order_status_distribution') }}</h2>
				<canvas id="statusPie" width="400" height="260" style="display:block;margin:8px auto;"></canvas>
				<div id="statusLegend" class="caption" style="padding:8px 16px;"></div>
			</div>

			<div class="card">
				<h2>{{ t(request, 'dashboard.ongoing_status_distribution') }}</h2>
				<canvas id="ongoingStatusPie" width="400" height="260" style="display:block;margin:8px auto;"></canvas>
				<div id="ongoingStatusLegend" class="caption" style="padding:8px 16px;"></div>
			</div>

			<div class="card">
				<h2>{{ t(request, 'dashboard.order_lifecycle_distribution') }}</h2>
				<canvas id="lifecyclePie" width="400" height="260" style="display:block;margin:8px auto;"></canvas>
				<div id="lifecycleLegend" class="caption" style="padding:8px 16px;"></div>
			</div>

			<div class="card">
				<h2>{{ t(request, 'dashboard.low_stock_best') }}</h2>
				<table>
					<thead>
						<tr><th>ID</th><th>SKU</th><th>Ürün Adı</th><th>Mevcut Stok</th><th>Satış (Toplam)</th></tr>
					</thead>
					<tbody>
					{% for it, onhand, sold in low_stock_best %}
						<tr>
							<td>{{ it.id }}</td>
							<td>{{ it.sku }}</td>
							<td>{{ it.name }}</td>
							<td>{{ onhand }}</td>
							<td>{{ sold }}</td>
						</tr>
					{% endfor %}
					</tbody>
				</table>
			</div>
		</div>

		<script>
		const form = document.getElementById('uploadForm');
		const result = document.getElementById('uploadResult');
		const logoutBtn = document.getElementById('logoutBtn');
		const labels = {
			uploading: "{{ t(request, 'dashboard.uploading') }}",
			upload_failed: "{{ t(request, 'dashboard.upload_failed') }}",
			uploaded_files_count_label: "{{ t(request, 'dashboard.uploaded_files_count') }}",
			confirm_import_all: "{{ t(request, 'dashboard.confirm_import_all') }}",
			unmatched_found_prompt: "{{ t(request, 'dashboard.unmatched_found_prompt') }}",
			import_failed_for: "{{ t(request, 'dashboard.import_failed_for') }}"
		};
		const DAILY_COUNTS = {{ (daily_counts or []) | tojson }};
		const DAILY_FINANCIALS = {{ (daily_financials or []) | tojson }};
		const STATUS_LABELS = {
			"tamamlandi": "{{ t(request, 'status.tamamlandi') }}",
			"dagitimda": "{{ t(request, 'status.dagitimda') }}",
			"gecikmede": "{{ t(request, 'status.gecikmede') }}",
			"sorunlu": "{{ t(request, 'status.sorunlu') }}",
			"refunded": "{{ t(request, 'status.refunded') }}",
			"switched": "{{ t(request, 'status.switched') }}",
			"stitched": "{{ t(request, 'status.stitched') }}",
			"unknown": "{{ t(request, 'status.unknown') }}"
		};
		if (logoutBtn) {
			logoutBtn.addEventListener('click', async () => {
				try {
					await fetch('/auth/logout', { method: 'POST' });
					location.href = '/auth/login';
				} catch (e) { /* ignore here; navbar handles messaging */ }
			});
		}
		if (form) {
			form.addEventListener('submit', async (e) => {
				e.preventDefault();
				const data = new FormData(form);
				result.textContent = labels.uploading;
				try {
					// pass skip_duplicates flag
					const res = await fetch('/import/upload', { method: 'POST', body: data });
					if (!res.ok) throw new Error(labels.upload_failed);
					const json = await res.json();
					result.textContent = `${labels.uploaded_files_count_label}: ${json.files.length}`;
					// For 'returns', redirect to interactive review for the first file
					if (json.source === 'returns' && json.files && json.files.length){
						const fn = encodeURIComponent(json.files[0].filename);
						location.href = `/import/returns/review?filename=${fn}`;
						return;
					}
					// For 'bizim', check unmatched patterns across all uploaded files and redirect to mapping wizard if needed
					if (json.source === 'bizim' && json.files && json.files.length) {
                        const fnames = json.files.map(f=>f.filename);
                        try {
                            const pm = await fetch('/import/preview-map', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ source: 'bizim', filenames: fnames, exclude_generic: false }) });
                            if (pm.ok) {
                                const j = await pm.json();
								if ((j.total_unmatched||0) > 0) {
									if (confirm(labels.unmatched_found_prompt.replace('{count}', j.total_unmatched))) {
                                        const joined = fnames.map(encodeURIComponent).join(',');
                                        location.href = `/import/map?source=bizim&filename=${joined}`;
                                        return;
                                    }
                                }
                            }
                        } catch (e) { /* ignore preview errors and continue to commit flow */ }
                    }

					// Offer to commit each file sequentially (date prompt only for bizim)
					const skipDup = document.getElementById('skipDupDash')?.checked;
					if (confirm(labels.confirm_import_all)) {
						const totals = { created_orders:0, created_clients:0, created_items:0, created_payments:0, unmatched:0, enriched_orders:0, payments_existing:0, payments_skipped_zero:0 };
						const runIds = [];
						for (const f of json.files) {
							let body = { source: json.source, filename: f.filename, skip_duplicates: skipDup };
							// returns are handled via interactive review; skip commit here
							if (json.source === 'returns') { continue; }
						// For 'bizim', data_date will be derived from filename (first 10 chars)
							const res2 = await fetch('/import/commit', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body)});
							if (!res2.ok) { const t = await res2.text(); throw new Error(`${labels.import_failed_for} ${f.filename}: ${t}`); }
							const j2 = await res2.json();
							console.group('Import result', f.filename);
							console.log('Summary:', j2);
							console.groupEnd();
							for (const k of Object.keys(totals)) { totals[k] += (j2[k] || 0); }
							if (j2.run_id) { runIds.push(j2.run_id); }
						}
						if (runIds.length) {
							const q = encodeURIComponent(runIds.join(','));
							location.href = `/import/result?run_ids=${q}`;
						} else {
							location.reload();
						}
					}
				} catch (err) {
					console.error(err);
					result.textContent = 'Yükleme hatası';
				}
			});
		}

		function renderLineChart(canvasId, labelsArr, datasets, legendId, fullLabels) {
			if (!labelsArr || !labelsArr.length || !datasets || !datasets.length) return;
			const canvas = document.getElementById(canvasId);
			if (!canvas) return;
			const ctx = canvas.getContext('2d');
			const w = canvas.width;
			const h = canvas.height;
			const pad = 36;
			const usableW = w - pad * 2;
			const usableH = h - pad * 2;
			const allValues = datasets.flatMap(d => d.data).map(v => Number(v || 0));
			if (!allValues.length) return;
			const maxVal = Math.max(...allValues, 1);
			const xCount = labelsArr.length;
			const xStep = xCount > 1 ? usableW / (xCount - 1) : 0;
			const yTicks = 4;

			ctx.clearRect(0, 0, w, h);
			ctx.font = '12px system-ui';
			ctx.strokeStyle = '#e5e7eb';
			ctx.lineWidth = 1;

			for (let i = 0; i <= yTicks; i++) {
				const frac = i / yTicks;
				const y = h - pad - frac * usableH;
				ctx.beginPath();
				ctx.moveTo(pad, y);
				ctx.lineTo(w - pad, y);
				ctx.stroke();
				const val = Math.round(maxVal * frac);
				ctx.fillStyle = '#6b7280';
				ctx.fillText(val.toString(), 4, y + 4);
			}

			const labelStep = Math.max(1, Math.ceil(xCount / 8));
			ctx.fillStyle = '#6b7280';
			for (let i = 0; i < xCount; i += labelStep) {
				const x = pad + i * xStep;
				const lbl = labelsArr[i];
				ctx.fillText(lbl, x - 12, h - 8);
			}

			const points = [];
			datasets.forEach((ds, di) => {
				ctx.strokeStyle = ds.color || '#2563eb';
				ctx.lineWidth = 2;
				ctx.beginPath();
				ds.data.forEach((v, idx) => {
					const x = pad + idx * xStep;
					const y = h - pad - (Number(v || 0) / maxVal) * usableH;
					if (idx === 0) ctx.moveTo(x, y);
					else ctx.lineTo(x, y);
					points.push({ x, y, idx, label: ds.label, color: ds.color || '#2563eb', value: Number(v || 0) });
				});
				ctx.stroke();
				ctx.fillStyle = ds.color || '#2563eb';
				ds.data.forEach((v, idx) => {
					const x = pad + idx * xStep;
					const y = h - pad - (Number(v || 0) / maxVal) * usableH;
					ctx.beginPath();
					ctx.arc(x, y, 3, 0, Math.PI * 2);
					ctx.fill();
				});
			});

			if (legendId) {
				const legend = document.getElementById(legendId);
				if (legend) {
					legend.innerHTML = datasets.map(ds => `<span style="display:inline-flex;align-items:center;margin-right:12px;">
						<span style="width:12px;height:12px;border-radius:999px;background:${ds.color};display:inline-block;margin-right:6px;"></span>
						${ds.label}
					</span>`).join('');
				}
			}

			// Tooltip on hover
			const tip = document.createElement('div');
			tip.style.position = 'absolute';
			tip.style.background = 'rgba(17,24,39,0.95)';
			tip.style.color = '#fff';
			tip.style.fontSize = '12px';
			tip.style.padding = '8px 10px';
			tip.style.borderRadius = '8px';
			tip.style.pointerEvents = 'none';
			tip.style.display = 'none';
			canvas.parentElement.style.position = 'relative';
			canvas.parentElement.appendChild(tip);

			function formatVal(v) {
				return Math.abs(v) >= 100 ? v.toFixed(0) : v.toFixed(2);
			}

			canvas.addEventListener('mousemove', (e) => {
				const rect = canvas.getBoundingClientRect();
				const parentRect = canvas.parentElement.getBoundingClientRect();
				const mx = e.clientX - rect.left;
				const my = e.clientY - rect.top;
				let best = null;
				let bestD = 12; // radius threshold
				for (const p of points) {
					const d = Math.hypot(p.x - mx, p.y - my);
					if (d < bestD) { bestD = d; best = p; }
				}
				if (!best) {
					tip.style.display = 'none';
					return;
				}
				const idx = best.idx;
				const dateLabel = (fullLabels && fullLabels[idx]) || labelsArr[idx] || '';
				const lines = datasets.map(ds => {
					const v = Number(ds.data[idx] || 0);
					return `<span style="color:${ds.color};font-weight:600">${ds.label}</span>: ${formatVal(v)}`;
				});
				tip.innerHTML = `<div style="font-weight:700;margin-bottom:4px;">${dateLabel}</div>${lines.join('<br>')}`;
				tip.style.left = (e.clientX - parentRect.left + 10) + 'px';
				tip.style.top = Math.max(0, e.clientY - parentRect.top - 10) + 'px';
				tip.style.display = 'block';
			});

			canvas.addEventListener('mouseleave', () => {
				tip.style.display = 'none';
			});
		}

		(function renderDailyCharts() {
			if (DAILY_COUNTS && DAILY_COUNTS.length) {
				const labels = DAILY_COUNTS.map(d => (d.date || '').slice(5));
				const fullLabels = DAILY_COUNTS.map(d => d.date || '');
				renderLineChart('dailyCountsChart', labels, [
					{ label: 'Satış', color: '#2563eb', data: DAILY_COUNTS.map(d => d.sales || 0) },
					{ label: 'İptal', color: '#f97316', data: DAILY_COUNTS.map(d => d.cancelled || 0) },
					{ label: 'İade', color: '#dc2626', data: DAILY_COUNTS.map(d => d.refunded || 0) },
				], 'dailyCountsLegend', fullLabels);
			}
			if (DAILY_FINANCIALS && DAILY_FINANCIALS.length) {
				const labels = DAILY_FINANCIALS.map(d => (d.date || '').slice(5));
				const fullLabels = DAILY_FINANCIALS.map(d => d.date || '');
				renderLineChart('dailyFinancialsChart', labels, [
					{ label: 'Ciro', color: '#0ea5e9', data: DAILY_FINANCIALS.map(d => d.revenue || 0) },
					{ label: 'Kâr', color: '#10b981', data: DAILY_FINANCIALS.map(d => d.profit || 0) },
					{ label: 'Maliyet', color: '#f59e0b', data: DAILY_FINANCIALS.map(d => d.cost || 0) },
				], 'dailyFinancialsLegend', fullLabels);
			}
		})();

		// Simple pie chart without external deps
		(function(){
			const data = {{ (order_status_counts or []) | tojson }};
			if (!data || !data.length) return;
			const canvas = document.getElementById('statusPie');
			if (!canvas) return;
			const ctx = canvas.getContext('2d');
			const total = data.reduce((s, r) => s + (r.count || 0), 0) || 1;
			// Palette order matches: tamamlandi, dagitimda, gecikmede, sorunlu, refunded, switched, stitched
			const colors = ['#10b981','#60a5fa','#f59e0b','#ef4444','#a78bfa','#fbbf24','#34d399'];
			let start = -Math.PI/2;
			data.forEach((r, i) => {
				const frac = (r.count || 0) / total;
				const end = start + frac * Math.PI * 2;
				ctx.beginPath();
				ctx.moveTo(canvas.width/2, canvas.height/2);
				ctx.arc(canvas.width/2, canvas.height/2, Math.min(canvas.width, canvas.height)/2 - 8, start, end);
				ctx.closePath();
				ctx.fillStyle = colors[i % colors.length];
				ctx.fill();
				start = end;
			});
			const legend = document.getElementById('statusLegend');
			if (legend) {
				const label = (s)=> STATUS_LABELS[String(s||'').toLowerCase()] || (String(s||'').charAt(0).toUpperCase() + String(s||'').slice(1));
				legend.innerHTML = data.map((r,i)=>`<span style="display:inline-flex;align-items:center;margin-right:12px;">
					<span style="display:inline-block;width:10px;height:10px;background:${colors[i%colors.length]};border-radius:2px;margin-right:6px;"></span>
					${label(r.status)}: <strong style="margin-left:4px;">${r.count}</strong>
				</span>`).join('');

				// Tooltip on hover
				const tip = document.createElement('div');
				tip.style.position = 'absolute';
				tip.style.background = 'rgba(17,24,39,0.9)';
				tip.style.color = '#fff';
				tip.style.fontSize = '12px';
				tip.style.padding = '6px 8px';
				tip.style.borderRadius = '6px';
				tip.style.pointerEvents = 'none';
				tip.style.display = 'none';
				canvas.parentElement.style.position = 'relative';
				canvas.parentElement.appendChild(tip);
				const totals = data.map(r=>r.count||0);
				const sum = totals.reduce((a,b)=>a+b,0)||1;
				const cum = []; let acc = 0; for(const r of totals){ acc += r/sum; cum.push(acc); }
				function sliceAt(theta){
					let t = theta; while (t < -Math.PI/2) t += Math.PI*2; while (t > Math.PI*3/2) t -= Math.PI*2;
					let frac = (t + Math.PI/2) / (Math.PI*2);
					for (let i=0;i<cum.length;i++){ if (frac <= cum[i]) return i; }
					return cum.length-1;
				}
				canvas.addEventListener('mousemove', (e)=>{
					const rect = canvas.getBoundingClientRect();
					const x = e.clientX - rect.left - canvas.width/2;
					const y = e.clientY - rect.top - canvas.height/2;
					const r = Math.min(canvas.width, canvas.height)/2 - 8;
					if (Math.sqrt(x*x + y*y) > r){ tip.style.display='none'; return; }
					const theta = Math.atan2(y, x);
					const idx = sliceAt(theta);
					const d = data[idx]; const cnt = totals[idx]; const pct = Math.round((cnt/sum)*1000)/10;
					tip.textContent = `${label(d.status)}: ${cnt} (${pct}%)`;
					tip.style.left = (e.clientX - rect.left + 10) + 'px';
					tip.style.top = (e.clientY - rect.top + 10) + 'px';
					tip.style.display = 'block';
				});
				canvas.addEventListener('mouseleave', ()=>{ tip.style.display='none'; });
			}
		})();

		// Ongoing status pie chart (excluding tamamlandi, refunded, switched)
		(function(){
			const data = {{ (ongoing_status_counts or []) | tojson }};
			if (!data || !data.length) return;
			const canvas = document.getElementById('ongoingStatusPie');
			if (!canvas) return;
			const ctx = canvas.getContext('2d');
			const total = data.reduce((s, r) => s + (r.count || 0), 0) || 1;
			// Palette for ongoing: dagitimda, gecikmede, sorunlu, stitched
			const colors = ['#60a5fa','#f59e0b','#ef4444','#34d399'];
			let start = -Math.PI/2;
			data.forEach((r, i) => {
				const frac = (r.count || 0) / total;
				const end = start + frac * Math.PI * 2;
				ctx.beginPath();
				ctx.moveTo(canvas.width/2, canvas.height/2);
				ctx.arc(canvas.width/2, canvas.height/2, Math.min(canvas.width, canvas.height)/2 - 8, start, end);
				ctx.closePath();
				ctx.fillStyle = colors[i % colors.length];
				ctx.fill();
				start = end;
			});
			const legend = document.getElementById('ongoingStatusLegend');
			if (legend) {
				const label = (s)=> STATUS_LABELS[String(s||'').toLowerCase()] || (String(s||'').charAt(0).toUpperCase() + String(s||'').slice(1));
				legend.innerHTML = data.map((r,i)=>`<span style="display:inline-flex;align-items:center;margin-right:12px;">
					<span style="display:inline-block;width:10px;height:10px;background:${colors[i%colors.length]};border-radius:2px;margin-right:6px;"></span>
					${label(r.status)}: <strong style="margin-left:4px;">${r.count}</strong>
				</span>`).join('');

				// Tooltip on hover
				const tip = document.createElement('div');
				tip.style.position = 'absolute';
				tip.style.background = 'rgba(17,24,39,0.9)';
				tip.style.color = '#fff';
				tip.style.fontSize = '12px';
				tip.style.padding = '6px 8px';
				tip.style.borderRadius = '6px';
				tip.style.pointerEvents = 'none';
				tip.style.display = 'none';
				canvas.parentElement.style.position = 'relative';
				canvas.parentElement.appendChild(tip);
				const totals = data.map(r=>r.count||0);
				const sum = totals.reduce((a,b)=>a+b,0)||1;
				const cum = []; let acc = 0; for(const r of totals){ acc += r/sum; cum.push(acc); }
				function sliceAt(theta){
					let t = theta; while (t < -Math.PI/2) t += Math.PI*2; while (t > Math.PI*3/2) t -= Math.PI*2;
					let frac = (t + Math.PI/2) / (Math.PI*2);
					for (let i=0;i<cum.length;i++){ if (frac <= cum[i]) return i; }
					return cum.length-1;
				}
				canvas.addEventListener('mousemove', (e)=>{
					const rect = canvas.getBoundingClientRect();
					const x = e.clientX - rect.left - canvas.width/2;
					const y = e.clientY - rect.top - canvas.height/2;
					const r = Math.min(canvas.width, canvas.height)/2 - 8;
					if (Math.sqrt(x*x + y*y) > r){ tip.style.display='none'; return; }
					const theta = Math.atan2(y, x);
					const idx = sliceAt(theta);
					const d = data[idx]; const cnt = totals[idx]; const pct = Math.round((cnt/sum)*1000)/10;
					tip.textContent = `${label(d.status)}: ${cnt} (${pct}%)`;
					tip.style.left = (e.clientX - rect.left + 10) + 'px';
					tip.style.top = (e.clientY - rect.top + 10) + 'px';
					tip.style.display = 'block';
				});
				canvas.addEventListener('mouseleave', ()=>{ tip.style.display='none'; });
			}
		})();

		// Order lifecycle pie chart (bizim orders: creation to payment time)
		(function(){
			const data = {{ (lifecycle_distribution or []) | tojson }};
			if (!data || !data.length) return;
			const canvas = document.getElementById('lifecyclePie');
			if (!canvas) return;
			const ctx = canvas.getContext('2d');
			const total = data.reduce((s, r) => s + (r.count || 0), 0) || 1;
			// Palette for lifecycle buckets: 0-3, 4-6, 7-9, 10-12, 13-15, 16+
			const colors = ['#10b981','#60a5fa','#f59e0b','#ef4444','#a78bfa','#fbbf24'];
			let start = -Math.PI/2;
			data.forEach((r, i) => {
				const frac = (r.count || 0) / total;
				const end = start + frac * Math.PI * 2;
				ctx.beginPath();
				ctx.moveTo(canvas.width/2, canvas.height/2);
				ctx.arc(canvas.width/2, canvas.height/2, Math.min(canvas.width, canvas.height)/2 - 8, start, end);
				ctx.closePath();
				ctx.fillStyle = colors[i % colors.length];
				ctx.fill();
				start = end;
			});
			const legend = document.getElementById('lifecycleLegend');
			if (legend) {
				const lifecycleLabels = {
					"0-3": "{{ t(request, 'dashboard.lifecycle_days_0_3') }}",
					"4-6": "{{ t(request, 'dashboard.lifecycle_days_4_6') }}",
					"7-9": "{{ t(request, 'dashboard.lifecycle_days_7_9') }}",
					"10-12": "{{ t(request, 'dashboard.lifecycle_days_10_12') }}",
					"13-15": "{{ t(request, 'dashboard.lifecycle_days_13_15') }}",
					"16+": "{{ t(request, 'dashboard.lifecycle_days_16_plus') }}"
				};
				const label = (b)=> lifecycleLabels[b] || b;
				legend.innerHTML = data.map((r,i)=>`<span style="display:inline-flex;align-items:center;margin-right:12px;">
					<span style="display:inline-block;width:10px;height:10px;background:${colors[i%colors.length]};border-radius:2px;margin-right:6px;"></span>
					${label(r.bucket)}: <strong style="margin-left:4px;">${r.count}</strong>
				</span>`).join('');

				// Tooltip on hover
				const tip = document.createElement('div');
				tip.style.position = 'absolute';
				tip.style.background = 'rgba(17,24,39,0.9)';
				tip.style.color = '#fff';
				tip.style.fontSize = '12px';
				tip.style.padding = '6px 8px';
				tip.style.borderRadius = '6px';
				tip.style.pointerEvents = 'none';
				tip.style.display = 'none';
				canvas.parentElement.style.position = 'relative';
				canvas.parentElement.appendChild(tip);
				const totals = data.map(r=>r.count||0);
				const sum = totals.reduce((a,b)=>a+b,0)||1;
				const cum = []; let acc = 0; for(const r of totals){ acc += r/sum; cum.push(acc); }
				function sliceAt(theta){
					let t = theta; while (t < -Math.PI/2) t += Math.PI*2; while (t > Math.PI*3/2) t -= Math.PI*2;
					let frac = (t + Math.PI/2) / (Math.PI*2);
					for (let i=0;i<cum.length;i++){ if (frac <= cum[i]) return i; }
					return cum.length-1;
				}
				canvas.addEventListener('mousemove', (e)=>{
					const rect = canvas.getBoundingClientRect();
					const x = e.clientX - rect.left - canvas.width/2;
					const y = e.clientY - rect.top - canvas.height/2;
					const r = Math.min(canvas.width, canvas.height)/2 - 8;
					if (Math.sqrt(x*x + y*y) > r){ tip.style.display='none'; return; }
					const theta = Math.atan2(y, x);
					const idx = sliceAt(theta);
					const d = data[idx]; const cnt = totals[idx]; const pct = Math.round((cnt/sum)*1000)/10;
					tip.textContent = `${label(d.bucket)}: ${cnt} (${pct}%)`;
					tip.style.left = (e.clientX - rect.left + 10) + 'px';
					tip.style.top = (e.clientY - rect.top + 10) + 'px';
					tip.style.display = 'block';
				});
				canvas.addEventListener('mouseleave', ()=>{ tip.style.display='none'; });
			}
		})();
		</script>
	</body>
</html>
